<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MWI Character Sheet Render</title>
  <style>
    body {
      margin: 0;
      background: #0b1020;
      color: #e7e7e7;
      font-family: system-ui, sans-serif;
    }

    #workspace {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      margin: 20px auto 0;
      width: fit-content;
      max-width: calc(100vw - 24px);
    }

    #target {
      width: 870px;
      height: 610px;
      display: block;
    }

    #edit-panel {
      width: 300px;
      height: 610px;
      max-height: 610px;
      box-sizing: border-box;
      border: 1px solid #3a4a70;
      border-radius: 8px;
      background: #141d37;
      padding: 12px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #edit-panel[hidden] {
      display: none;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
      flex: 0 0 auto;
    }

    #edit-fields {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-title {
      margin: 0;
      font-size: 16px;
      color: #c7b5e3;
    }

    .section-title {
      margin: 10px 0 8px;
      font-size: 13px;
      letter-spacing: 0.02em;
      color: #98a7e9;
      text-transform: uppercase;
    }

    .field {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .field label {
      font-size: 12px;
      color: #c7b5e3;
      text-transform: capitalize;
    }

    .field input {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #3a4a70;
      background: #0f1630;
      color: #e7e7e7;
      font-size: 14px;
    }

    .field select {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #3a4a70;
      background: #0f1630;
      color: #e7e7e7;
      font-size: 14px;
    }

    .field input[type='checkbox'] {
      width: auto;
      padding: 0;
      border: none;
      background: transparent;
      accent-color: #98a7e9;
    }

    .field-checkbox {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #e7e7e7;
      cursor: pointer;
      user-select: none;
      text-transform: none;
    }

    .field-inline-controls {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 88px;
      gap: 8px;
      align-items: center;
    }

    .copy-btn {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      padding: 10px 16px;
      background: #24304f;
      color: #e7e7e7;
      border: 1px solid #3a4a70;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    #button-row {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 20px auto 0;
    }

    #copy-img-btn:disabled,
    #copy-lnk-btn:disabled {
      opacity: 0.6;
      cursor: progress;
    }

    #whats-new-anchor {
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 30;
    }

    #whats-new-btn {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      padding: 0;
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
    }

    #whats-new-popover {
      position: absolute;
      top: 38px;
      right: 0;
      width: min(360px, calc(100vw - 28px));
      max-height: min(70vh, 520px);
      border: 1px solid #3a4a70;
      border-radius: 8px;
      background: #141d37;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.45);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #whats-new-popover[hidden] {
      display: none;
    }

    .whats-new-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid #3a4a70;
    }

    .whats-new-title {
      margin: 0;
      font-size: 14px;
      color: #c7b5e3;
    }

    #whats-new-content {
      padding: 10px 12px;
      overflow: auto;
    }

    .whats-new-entry {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #2a3558;
    }

    .whats-new-entry:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: 0;
    }

    .whats-new-date {
      margin: 0 0 4px;
      font-size: 12px;
      color: #98a7e9;
    }

    .whats-new-summary {
      margin: 0;
      font-size: 13px;
      line-height: 1.35;
      color: #e7e7e7;
    }

    @media (max-width: 1220px) {
      #workspace {
        flex-direction: column;
        width: calc(100vw - 24px);
      }

      #target {
        width: 100%;
        height: auto;
      }

      #target svg {
        width: 100%;
        height: auto;
      }

      #edit-panel {
        width: 100%;
        height: auto;
        max-height: none;
        min-height: 0;
      }
    }
  </style>
</head>
<body>
  <div id="whats-new-anchor">
    <button id="whats-new-btn" class="copy-btn" type="button" aria-label="Show what is new" aria-expanded="false" aria-controls="whats-new-popover">i</button>
    <section id="whats-new-popover" hidden>
      <div class="whats-new-header">
        <h2 class="whats-new-title">What&apos;s New</h2>
      </div>
      <div id="whats-new-content">Loading…</div>
    </section>
  </div>

  <div id="workspace">
    <div id="target">Loading…</div>
    <aside id="edit-panel" hidden>
      <div class="panel-header">
        <h2 id="edit-title" class="panel-title">Edit</h2>
        <button id="edit-close-btn" class="copy-btn" type="button">Close</button>
      </div>
      <div id="edit-fields"></div>
    </aside>
  </div>

  <div id="button-row">
    <button id="edit-mode-btn" class="copy-btn" type="button">Edit mode</button>
    <button id="copy-img-btn" class="copy-btn" type="button">Copy image</button>
    <button id="copy-lnk-btn" class="copy-btn" type="button">Copy link</button>
  </div>

  <script type="module">
    const svgUrl = './assets/images/loadout_combat.svg';
    const slotRulesUrl = './assets/data/slot-rules.json';
    const itemDataUrl = './assets/data/item-data.json';
    const whatsNewUrl = './assets/data/whats-new.json';
    const symbolFileCache = new Map();
    const symbolOptionsCache = new Map();
    const imageDataCache = new Map();

    const targetEl = document.getElementById('target');
    const editPanelEl = document.getElementById('edit-panel');
    const editFieldsEl = document.getElementById('edit-fields');
    const editTitleEl = document.getElementById('edit-title');
    const editModeBtnEl = document.getElementById('edit-mode-btn');
    const whatsNewBtnEl = document.getElementById('whats-new-btn');
    const whatsNewPopoverEl = document.getElementById('whats-new-popover');
    const whatsNewContentEl = document.getElementById('whats-new-content');

    let currentParsed = null;
    let currentRenderMap = null;
    let currentSlotRules = null;
    let currentItemData = null;
    let currentWhatsNew = null;
    let currentSvgText = '';
    let currentEditSection = null;
    let isEditMode = false;
    const itemMetaCache = new Map();

    const EDITOR_PANELS = {
      character: ['general', 'achievements'],
      equipment: ['equipment'],
      skills: ['skills'],
      abilities: ['abilities'],
      consumables: ['consumables'],
      housing: ['housing'],
    };

    const fetchSvg = async () => {
      const res = await fetch(svgUrl);
      if (!res.ok) throw new Error('Failed to fetch SVG');
      return res.text();
    };

    const fetchSlotRules = async () => {
      const res = await fetch(slotRulesUrl);
      if (!res.ok) return { enumOptions: {}, symbolRules: {}, slotRules: {} };
      try {
        const parsed = await res.json();
        return parsed && typeof parsed === 'object' ? parsed : { enumOptions: {}, symbolRules: {}, slotRules: {} };
      } catch (e) {
        return { enumOptions: {}, symbolRules: {}, slotRules: {} };
      }
    };

    const fetchItemData = async () => {
      const res = await fetch(itemDataUrl);
      if (!res.ok) return {};
      try {
        const parsed = await res.json();
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (e) {
        return {};
      }
    };

    const fetchWhatsNew = async () => {
      const res = await fetch(whatsNewUrl);
      if (!res.ok) return { entries: [] };
      try {
        const parsed = await res.json();
        return parsed && typeof parsed === 'object' ? parsed : { entries: [] };
      } catch (e) {
        return { entries: [] };
      }
    };

    const readRenderMap = (svgText) => {
      const match = svgText.match(/render-map:\s*([\s\S]*?)-->/);
      if (!match) return null;
      try {
        return JSON.parse(match[1]);
      } catch (e) {
        return null;
      }
    };

    const splitWithKeys = (str, delimiter, keys) => {
      if (!keys || !Array.isArray(keys)) return {};
      const parts = delimiter !== null && delimiter !== undefined ? (str ? str.split(delimiter) : []) : [str];
      const out = {};
      keys.forEach((k, idx) => {
        out[k] = parts[idx] !== undefined ? parts[idx] : '';
      });
      return out;
    };

    const parseByMap = (str, mapNode) => {
      if (!mapNode || !mapNode.keys) return str;
      const base = splitWithKeys(str, mapNode.delimiter, mapNode.keys);
      const result = {};
      mapNode.keys.forEach((k) => {
        const childMap = mapNode[k];
        const val = base[k] === undefined ? '' : base[k];
        result[k] = childMap ? parseByMap(val, childMap) : val;
      });
      return result;
    };

    const serializeByMap = (obj, mapNode) => {
      if (!mapNode || !mapNode.keys) {
        return obj === undefined || obj === null ? '' : String(obj);
      }
      const parts = mapNode.keys.map((k) => {
        const childMap = mapNode[k];
        const childVal = obj && typeof obj === 'object' ? obj[k] : '';
        return childMap ? serializeByMap(childVal, childMap) : (childVal === undefined || childVal === null ? '' : String(childVal));
      });
      const delimiter = mapNode.delimiter !== undefined && mapNode.delimiter !== null ? mapNode.delimiter : '';
      return parts.join(delimiter);
    };

    const flatten = (obj, mapNode, joinBy, prefixKey = '', inherited = {}, out = {}) => {
      if (obj === null || obj === undefined) return out;
      if (!mapNode) return out;
      const currentPrefix = mapNode.prefix !== undefined ? mapNode.prefix : inherited.prefix;
      const currentDefault = mapNode.default !== undefined ? mapNode.default : inherited.default;

      if (!mapNode.keys || typeof obj !== 'object') {
        const val = (obj === '' || obj === undefined || obj === null) ? (currentDefault !== undefined ? currentDefault : '') : obj;
        const finalVal = currentPrefix && val ? `${currentPrefix}${val}` : val;
        if (prefixKey) out[prefixKey] = finalVal;
        return out;
      }

      mapNode.keys.forEach((k) => {
        const nextKey = prefixKey ? `${prefixKey}${joinBy}${k}` : k;
        const childMap = mapNode[k] || {};
        const childVal = obj[k] !== undefined ? obj[k] : '';
        if (typeof childVal === 'object' && childVal !== null && childMap.keys) {
          flatten(childVal, childMap, joinBy, nextKey, { prefix: childMap.prefix ?? currentPrefix, default: childMap.default ?? currentDefault }, out);
        } else {
          const val = (childVal === '' || childVal === undefined || childVal === null) ? (childMap.default !== undefined ? childMap.default : currentDefault !== undefined ? currentDefault : '') : childVal;
          const finalVal = (childMap.prefix !== undefined ? childMap.prefix : currentPrefix) && val ? `${childMap.prefix !== undefined ? childMap.prefix : currentPrefix}${val}` : val;
          out[nextKey] = finalVal;
        }
      });
      return out;
    };

    const applyReplacements = (svgText, replacements) => {
      let out = svgText;
      Object.entries(replacements).forEach(([key, val]) => {
        const re = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        out = out.replace(re, val === undefined || val === null ? '' : String(val));
      });
      return out;
    };

    const getSvgDimensions = (svgEl) => {
      const viewBox = svgEl.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.split(/[\s,]+/).map((p) => parseFloat(p));
        if (parts.length === 4 && !parts.some(Number.isNaN)) return { width: parts[2], height: parts[3] };
      }

      const widthAttr = parseFloat(svgEl.getAttribute('width'));
      const heightAttr = parseFloat(svgEl.getAttribute('height'));
      if (!Number.isNaN(widthAttr) && !Number.isNaN(heightAttr) && widthAttr && heightAttr) {
        return { width: widthAttr, height: heightAttr };
      }

      const rect = svgEl.getBoundingClientRect();
      if (rect.width && rect.height) return { width: rect.width, height: rect.height };

      return { width: 870, height: 610 };
    };

    const svgToPngBlob = async (svgEl) => new Promise((resolve, reject) => {
      const clone = svgEl.cloneNode(true);
      if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      inlineExternalAssets(clone).then(() => {
        const serialized = new XMLSerializer().serializeToString(clone);
        const svgBlob = new Blob([serialized], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        const { width, height } = getSvgDimensions(svgEl);

        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d', { willReadFrequently: false });
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          canvas.toBlob((blob) => {
            URL.revokeObjectURL(url);
            if (blob) resolve(blob);
            else reject(new Error('Canvas export failed'));
          }, 'image/png');
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('SVG could not be loaded for export'));
        };

        img.src = url;
      }).catch(reject);
    });

    const copyImage = async () => {
      const btn = document.getElementById('copy-img-btn');
      const svgEl = document.querySelector('#target svg');
      if (!navigator.clipboard || !window.ClipboardItem) {
        btn.textContent = 'Clipboard not supported';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 2000);
        return;
      }
      if (!svgEl) {
        btn.textContent = 'SVG not ready';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 1500);
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Copying…';
      try {
        const blobPromise = svgToPngBlob(svgEl);
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blobPromise })]);
        await blobPromise;
        btn.textContent = 'Copied!';
      } catch (err) {
        console.error(err);
        btn.textContent = 'Copy failed';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = 'Copy image';
        }, 1200);
      }
    };

    const copyLink = async () => {
      const btn = document.getElementById('copy-lnk-btn');
      if (!navigator.clipboard || !window.ClipboardItem) {
        btn.textContent = 'Clipboard not supported';
        setTimeout(() => { btn.textContent = 'Copy link'; }, 2000);
        return;
      }

      const name = currentParsed?.general?.name || 'Player';
      const combat = currentParsed?.skills?.combat || '';
      const label = `Combat Sheet for ${name}` + (combat ? ` (CL ${combat})` : '');
      const url = location.href;

      const html = `<a href="${url}">${label}</a>`;
      const plain = `[${label}](${url})`;

      const item = new ClipboardItem({
        'text/html': new Blob([html], { type: 'text/html' }),
        'text/plain': new Blob([plain], { type: 'text/plain' }),
      });

      btn.disabled = true;
      btn.textContent = 'Copying…';
      try {
        await navigator.clipboard.write([item]);
        btn.textContent = 'Copied!';
      } catch (err) {
        console.error(err);
        btn.textContent = 'Copy failed';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = 'Copy link';
        }, 1200);
      }
    };

    const updateUrlFromState = () => {
      if (!currentParsed || !currentRenderMap || !currentRenderMap.split) return;
      const urpt = serializeByMap(currentParsed, currentRenderMap.split);
      const current = location.search.startsWith('?') ? location.search.slice(1) : '';
      const kept = current
        .split('&')
        .filter((part) => part && !part.startsWith('urpt='));
      if (urpt) kept.unshift(`urpt=${urpt}`);
      const query = kept.length ? `?${kept.join('&')}` : '';
      const nextUrl = `${location.pathname}${query}${location.hash}`;
      history.replaceState(null, '', nextUrl);
    };

    const getRawQueryParam = (name) => {
      const raw = location.search.startsWith('?') ? location.search.slice(1) : '';
      if (!raw) return '';
      const parts = raw.split('&');
      const prefix = `${name}=`;
      const match = parts.find((part) => part.startsWith(prefix));
      return match ? match.slice(prefix.length) : '';
    };

    const getFieldBounds = (section, key) => {
      const sectionMap = currentRenderMap?.split?.[section] || {};
      const editor = sectionMap.editor || {};
      const fieldEditor = (editor.fields && editor.fields[key]) || {};

      const sectionMin = Number.isFinite(Number(editor.min)) ? Number(editor.min) : null;
      const sectionMax = Number.isFinite(Number(editor.max)) ? Number(editor.max) : null;
      const fieldMin = Number.isFinite(Number(fieldEditor.min)) ? Number(fieldEditor.min) : null;
      const fieldMax = Number.isFinite(Number(fieldEditor.max)) ? Number(fieldEditor.max) : null;

      return {
        min: fieldMin !== null ? fieldMin : sectionMin,
        max: fieldMax !== null ? fieldMax : sectionMax,
      };
    };

    const resolveEnumOptions = (section, key, fieldEditor) => {
      if (Array.isArray(fieldEditor?.options)) return fieldEditor.options;
      const ref = fieldEditor?.optionsRef || `${section}.${key}`;
      const enumOptions = currentSlotRules?.enumOptions || {};
      const options = enumOptions[ref];
      if (Array.isArray(options)) return options;
      return [];
    };

    const getByPath = (obj, path) => {
      if (!obj || typeof obj !== 'object' || !path) return undefined;
      const parts = String(path).split('.').filter(Boolean);
      let node = obj;
      for (const part of parts) {
        if (node === null || typeof node !== 'object') return undefined;
        node = node[part];
        if (node === undefined) return undefined;
      }
      return node;
    };

    const getItemDataForSymbol = (symbolId) => {
      if (!currentItemData || typeof currentItemData !== 'object') return null;
      return currentItemData[`/items/${symbolId}`] || null;
    };

    const toTitleCase = (txt) => String(txt ?? '')
      .replaceAll('_', ' ')
      .split(/\s+/)
      .filter(Boolean)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    const getRequiredProgressLevel = (itemData) => {
      if (!itemData || typeof itemData !== 'object') return Number.MAX_SAFE_INTEGER;
      const levels = [];
      const walk = (node) => {
        if (!node || typeof node !== 'object') return;
        if (Array.isArray(node)) {
          node.forEach((entry) => walk(entry));
          return;
        }
        const reqs = node.levelRequirements;
        if (Array.isArray(reqs)) {
          reqs.forEach((req) => {
            const lvl = Number(req?.level);
            if (Number.isFinite(lvl)) levels.push(lvl);
          });
        }
        Object.values(node).forEach((value) => {
          if (value && typeof value === 'object') walk(value);
        });
      };
      walk(itemData);
      if (levels.length) return Math.min(...levels);
      const itemLevel = Number(itemData?.itemLevel);
      return Number.isFinite(itemLevel) ? itemLevel : Number.MAX_SAFE_INTEGER;
    };

    const getSymbolMeta = (symbolId) => {
      const id = String(symbolId ?? '');
      if (itemMetaCache.has(id)) return itemMetaCache.get(id);
      const itemData = getItemDataForSymbol(id);
      const meta = {
        label: itemData?.name || toTitleCase(id),
        requiredLevel: getRequiredProgressLevel(itemData),
      };
      itemMetaCache.set(id, meta);
      return meta;
    };

    const getSortedSymbolEntries = (rawOptions) => {
      const entries = (Array.isArray(rawOptions) ? rawOptions : []).map((symbolId) => {
        const meta = getSymbolMeta(symbolId);
        return {
          symbolId,
          label: meta.label,
          requiredLevel: meta.requiredLevel,
        };
      });
      entries.sort((a, b) => {
        const levelA = Number.isFinite(a.requiredLevel) ? a.requiredLevel : Number.MAX_SAFE_INTEGER;
        const levelB = Number.isFinite(b.requiredLevel) ? b.requiredLevel : Number.MAX_SAFE_INTEGER;
        if (levelA !== levelB) return levelA - levelB;
        const byLabel = a.label.localeCompare(b.label, undefined, { sensitivity: 'base' });
        if (byLabel !== 0) return byLabel;
        return String(a.symbolId).localeCompare(String(b.symbolId), undefined, { sensitivity: 'base' });
      });
      return entries;
    };

    const matchesSymbolRule = (symbolId, rule, itemData = null) => {
      if (!rule || typeof rule !== 'object') return false;
      const type = rule.type || 'static';
      const value = String(rule.value ?? '');
      if (!value && !['itemPathEquals', 'itemPathRegex', 'item_path_equals', 'item_path_regex'].includes(type)) return false;

      if (type === 'static') return symbolId === value;
      if (type === 'prefix') return symbolId.startsWith(value);
      if (type === 'regex') {
        try {
          return new RegExp(value).test(symbolId);
        } catch (e) {
          return false;
        }
      }
      if (type === 'itemCategory' || type === 'item_category') {
        return String(itemData?.categoryHrid ?? '') === value;
      }
      if (type === 'equipmentType' || type === 'equipment_type') {
        return String(itemData?.equipmentDetail?.type ?? '') === value;
      }
      if (type === 'itemPathEquals' || type === 'item_path_equals') {
        const path = String(rule.path ?? '');
        if (!path) return false;
        return String(getByPath(itemData, path) ?? '') === value;
      }
      if (type === 'itemPathRegex' || type === 'item_path_regex') {
        const path = String(rule.path ?? '');
        if (!path || !value) return false;
        try {
          return new RegExp(value).test(String(getByPath(itemData, path) ?? ''));
        } catch (e) {
          return false;
        }
      }
      return false;
    };

    const resolveSymbolOptions = (section, key, rawOptions, fieldEditor = {}) => {
      const ref = fieldEditor?.rulesRef || `${section}.${key}`;
      const symbolRules = currentSlotRules?.symbolRules || {};
      const ruleSet = symbolRules[ref];
      if (!ruleSet || typeof ruleSet !== 'object') return rawOptions;

      let options = Array.isArray(rawOptions) ? [...rawOptions] : [];
      const include = Array.isArray(ruleSet.include) ? ruleSet.include : [];
      const exclude = Array.isArray(ruleSet.exclude) ? ruleSet.exclude : [];

      if (include.length) {
        options = options.filter((symbolId) => {
          const itemData = getItemDataForSymbol(symbolId);
          return include.some((rule) => matchesSymbolRule(symbolId, rule, itemData));
        });
      }
      if (exclude.length) {
        options = options.filter((symbolId) => {
          const itemData = getItemDataForSymbol(symbolId);
          return !exclude.some((rule) => matchesSymbolRule(symbolId, rule, itemData));
        });
      }
      return options;
    };

    const normalizeNumericValue = (rawValue, min, max) => {
      const txt = String(rawValue ?? '').trim();
      if (txt === '') return '';
      const parsed = Number.parseInt(txt, 10);
      if (!Number.isFinite(parsed)) return '';
      let value = parsed;
      if (min !== null) value = Math.max(min, value);
      if (max !== null) value = Math.min(max, value);
      return String(value);
    };

    const normalizeEditorNumericValue = (value, fieldEditor = {}) => {
      if (value === '' || value === null || value === undefined) return '';
      if (fieldEditor?.emptyWhenZero === true && Number(value) === 0) return '';
      return String(value);
    };

    const humanizeKey = (key) => key.replaceAll('_', ' ');

    const formatShortDate = (value) => {
      const txt = String(value ?? '').trim();
      if (!txt) return '';
      const date = new Date(`${txt}T12:00:00Z`);
      if (Number.isNaN(date.getTime())) return txt;
      return new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        timeZone: 'UTC',
      }).format(date);
    };

    const renderWhatsNew = (payload) => {
      if (!whatsNewContentEl) return;
      const entries = Array.isArray(payload?.entries) ? payload.entries : [];
      whatsNewContentEl.innerHTML = '';
      if (!entries.length) {
        const empty = document.createElement('p');
        empty.className = 'whats-new-summary';
        empty.textContent = 'No updates available yet.';
        whatsNewContentEl.appendChild(empty);
        return;
      }

      entries.forEach((entry) => {
        const dateText = formatShortDate(entry?.date);
        const summaryText = String(entry?.summary ?? '').trim();
        if (!dateText && !summaryText) return;

        const row = document.createElement('article');
        row.className = 'whats-new-entry';
        const date = document.createElement('h3');
        date.className = 'whats-new-date';
        date.textContent = dateText || 'Update';
        const summary = document.createElement('p');
        summary.className = 'whats-new-summary';
        summary.textContent = summaryText || 'Update details coming soon.';
        row.appendChild(date);
        row.appendChild(summary);
        whatsNewContentEl.appendChild(row);
      });
    };

    const getSectionValue = (section, key) => {
      const sectionState = currentParsed?.[section];
      if (!sectionState || typeof sectionState !== 'object') return '';
      const path = String(key ?? '').split('.').filter(Boolean);
      if (!path.length) return '';
      let node = sectionState;
      for (const part of path) {
        if (node === null || typeof node !== 'object') return '';
        node = node[part];
        if (node === undefined) return '';
      }
      return node;
    };

    const setSectionValue = (section, key, value) => {
      if (!currentParsed) return;
      if (!currentParsed[section] || typeof currentParsed[section] !== 'object') {
        currentParsed[section] = {};
      }
      const path = String(key ?? '').split('.').filter(Boolean);
      if (!path.length) return;
      let node = currentParsed[section];
      for (let idx = 0; idx < path.length - 1; idx += 1) {
        const part = path[idx];
        if (!node[part] || typeof node[part] !== 'object') node[part] = {};
        node = node[part];
      }
      node[path[path.length - 1]] = value;
    };

    const resolveNumericBounds = (section, key, fieldEditor = {}) => {
      const rootKey = String(key ?? '').split('.')[0];
      const base = getFieldBounds(section, rootKey);
      const fieldMin = Number.isFinite(Number(fieldEditor?.min)) ? Number(fieldEditor.min) : null;
      const fieldMax = Number.isFinite(Number(fieldEditor?.max)) ? Number(fieldEditor.max) : null;
      return {
        min: fieldMin !== null ? fieldMin : base.min,
        max: fieldMax !== null ? fieldMax : base.max,
      };
    };

    const updateRenderedSectionValues = (section) => {
      const svgEl = document.querySelector('#target svg');
      if (!svgEl || !currentRenderMap?.split?.[section]) return;

      const sectionMap = currentRenderMap.split[section];
      const sectionState = currentParsed?.[section] || {};
      const withPrefix = (value, mapNode) => {
        const prefix = mapNode?.prefix;
        const hasValue = !(value === '' || value === null || value === undefined);
        if (prefix && hasValue) return `${prefix}${value}`;
        return hasValue ? value : '';
      };

      if (section === 'skills') {
        const valueNodes = (sectionMap?.editor?.valueNodes && typeof sectionMap.editor.valueNodes === 'object')
          ? sectionMap.editor.valueNodes
          : {};
        sectionMap.keys.forEach((key, idx) => {
          const nodeId = valueNodes[key] || `skill-level-${idx + 1}`;
          const node = svgEl.querySelector(`#${nodeId}`);
          if (node) node.textContent = sectionState[key] ?? '';
        });
      }

      if (section === 'housing') {
        const housingEditor = sectionMap?.editor || {};
        sectionMap.keys.forEach((key) => {
          const node = svgEl.querySelector(`#housing-level-${key}`);
          if (node) node.textContent = normalizeEditorNumericValue(sectionState[key], housingEditor);
        });
      }

      if (section === 'equipment') {
        const equipmentLevelEditor = sectionMap?.editor?.level || {};
        sectionMap.keys.forEach((key) => {
          const node = svgEl.querySelector(`#equip-level-${key}`);
          if (node) {
            const rawLevelValue = sectionState?.[key]?.level ?? '';
            const levelValue = normalizeEditorNumericValue(rawLevelValue, equipmentLevelEditor);
            node.textContent = withPrefix(levelValue, sectionMap?.[key]?.level);
          }
        });
      }

      if (section === 'abilities') {
        sectionMap.keys.forEach((key, idx) => {
          const node = svgEl.querySelector(`#ability-level-${idx + 1}`);
          if (node) node.textContent = sectionState?.[key]?.level ?? '';
        });
      }
    };

    const getSymbolOptions = async (catalogPath) => {
      if (!catalogPath) return [];
      if (symbolOptionsCache.has(catalogPath)) return symbolOptionsCache.get(catalogPath);

      let text = symbolFileCache.get(catalogPath);
      if (!text) {
        const res = await fetch(catalogPath);
        if (!res.ok) {
          symbolOptionsCache.set(catalogPath, []);
          return [];
        }
        text = await res.text();
        symbolFileCache.set(catalogPath, text);
      }

      const doc = new DOMParser().parseFromString(text, 'image/svg+xml');
      const ids = Array.from(doc.querySelectorAll('symbol[id]'))
        .map((el) => el.getAttribute('id'))
        .filter((id) => Boolean(id));
      symbolOptionsCache.set(catalogPath, ids);
      return ids;
    };

    const handleNumericEdit = async (section, key, rawValue, inputEl, fieldEditor = {}) => {
      if (!currentParsed) return;
      if (section === 'skills' && key === 'combat') return;

      const bounds = resolveNumericBounds(section, key, fieldEditor);
      const normalized = normalizeEditorNumericValue(
        normalizeNumericValue(rawValue, bounds.min, bounds.max),
        fieldEditor,
      );
      setSectionValue(section, key, normalized);

      if (section === 'skills' && key !== 'combat') {
        applyComputedCombat(currentParsed);
      }

      if (inputEl) {
        inputEl.value = getSectionValue(section, key) ?? '';
      }

      const handledByTargetedUpdate = ['skills', 'housing', 'equipment', 'abilities'];
      if (handledByTargetedUpdate.includes(section)) {
        updateRenderedSectionValues(section);
      } else {
        await renderSheet({ refreshEditor: false });
      }
      if (section === 'skills' && key !== 'combat' && currentEditSection === 'skills') {
        const combatInput = editFieldsEl.querySelector('input[name="combat"]');
        if (combatInput) combatInput.value = currentParsed.skills?.combat ?? '';
      }
      updateUrlFromState();
    };

    const applyNonNumericEdit = async (section, key, value) => {
      if (!currentParsed) return;
      setSectionValue(section, key, value);
      if (section === 'skills' && key !== 'combat') {
        applyComputedCombat(currentParsed);
      }
      await renderSheet({ refreshEditor: false });
      updateUrlFromState();
    };

    const renderEditorFields = async (panelKey) => {
      if (!currentRenderMap?.split || !currentParsed) return;
      const sections = EDITOR_PANELS[panelKey];
      if (!sections || !sections.length) return;

      const panelLabelMap = {
        character: 'Character',
        equipment: 'Equipment',
        skills: 'Skills',
        abilities: 'Abilities',
        consumables: 'Consumables',
        housing: 'Housing',
      };
      const panelLabel = panelLabelMap[panelKey] || humanizeKey(panelKey);
      editTitleEl.textContent = `Edit ${panelLabel}`;
      editFieldsEl.innerHTML = '';

      for (const section of sections) {
        const sectionMap = currentRenderMap.split[section];
        if (!sectionMap || !Array.isArray(sectionMap.keys)) continue;

        const state = currentParsed[section] || {};
        const sectionEditor = sectionMap.editor || {};
        const hiddenKeys = new Set(Array.isArray(sectionEditor.hiddenKeys) ? sectionEditor.hiddenKeys : []);

        if (sections.length > 1) {
          const sectionTitle = document.createElement('h3');
          sectionTitle.className = 'section-title';
          sectionTitle.textContent = section === 'general' ? 'General' : section === 'achievements' ? 'Achievements' : humanizeKey(section);
          editFieldsEl.appendChild(sectionTitle);
        }

        if (section === 'abilities') {
          const itemDefaults = sectionEditor.item || {};
          const levelDefaults = sectionEditor.level || {};

          for (const key of sectionMap.keys) {
            const slotMap = sectionMap[key] || {};
            const slotState = (state[key] && typeof state[key] === 'object') ? state[key] : {};
            const slotLabel = sectionEditor?.labels?.[key] || `Ability ${key}`;
            const slotFieldEditor = (sectionEditor.fields && sectionEditor.fields[key]) || {};

            const itemMap = slotMap.item || {};
            const itemEditor = { ...itemDefaults, ...slotFieldEditor, ...(itemMap.editor || {}) };
            const wrapper = document.createElement('div');
            wrapper.className = 'field';
            const label = document.createElement('label');
            label.setAttribute('for', `edit-${section}-${key}-item`);
            label.textContent = slotLabel;
            wrapper.appendChild(label);

            const controlsRow = document.createElement('div');
            controlsRow.className = 'field-inline-controls';
            const itemSelect = document.createElement('select');
            itemSelect.id = `edit-${section}-${key}-item`;
            itemSelect.name = `${key}.item`;
            const itemCatalog = itemEditor.catalog || ((itemMap.prefix || '').split('#')[0] || '');
            const itemAllowEmpty = itemEditor.allowEmpty !== false;
            const itemOptions = resolveSymbolOptions(section, key, await getSymbolOptions(itemCatalog), itemEditor);
            if (itemAllowEmpty) {
              const noneOpt = document.createElement('option');
              noneOpt.value = '';
              noneOpt.textContent = '(None)';
              itemSelect.appendChild(noneOpt);
            }
            const itemEntries = getSortedSymbolEntries(itemOptions);
            itemEntries.forEach(({ symbolId, label: optionLabel }) => {
              const opt = document.createElement('option');
              opt.value = symbolId;
              opt.textContent = optionLabel;
              itemSelect.appendChild(opt);
            });
            itemSelect.value = slotState.item ?? '';
            itemSelect.addEventListener('change', async () => {
              await applyNonNumericEdit(section, `${key}.item`, itemSelect.value);
            });
            controlsRow.appendChild(itemSelect);

            const levelMap = slotMap.level || {};
            const levelEditor = { ...levelDefaults, ...slotFieldEditor, ...(levelMap.editor || {}) };
            const levelBounds = resolveNumericBounds(section, `${key}.level`, levelEditor);
            const levelInput = document.createElement('input');
            levelInput.id = `edit-${section}-${key}-level`;
            levelInput.name = `${key}.level`;
            levelInput.type = 'number';
            levelInput.step = '1';
            levelInput.placeholder = 'Level';
            if (levelBounds.min !== null) levelInput.min = String(levelBounds.min);
            if (levelBounds.max !== null) levelInput.max = String(levelBounds.max);
            levelInput.value = normalizeEditorNumericValue(slotState.level, levelEditor);
            levelInput.addEventListener('change', () => {
              handleNumericEdit(section, `${key}.level`, levelInput.value, levelInput, levelEditor);
            });
            controlsRow.appendChild(levelInput);

            wrapper.appendChild(controlsRow);
            editFieldsEl.appendChild(wrapper);
          }

          continue;
        }

        if (section === 'equipment') {
          const itemDefaults = sectionEditor.item || {};
          const levelDefaults = sectionEditor.level || {};

          for (const key of sectionMap.keys) {
            const slotMap = sectionMap[key] || {};
            const slotState = (state[key] && typeof state[key] === 'object') ? state[key] : {};
            const slotLabel = sectionEditor?.labels?.[key] || humanizeKey(key);
            const slotFieldEditor = (sectionEditor.fields && sectionEditor.fields[key]) || {};

            const itemMap = slotMap.item || {};
            const itemEditor = { ...itemDefaults, ...slotFieldEditor, ...(itemMap.editor || {}) };
            const wrapper = document.createElement('div');
            wrapper.className = 'field';
            const label = document.createElement('label');
            label.setAttribute('for', `edit-${section}-${key}-item`);
            label.textContent = slotLabel;
            wrapper.appendChild(label);

            const controlsRow = document.createElement('div');
            controlsRow.className = 'field-inline-controls';
            const itemSelect = document.createElement('select');
            itemSelect.id = `edit-${section}-${key}-item`;
            itemSelect.name = `${key}.item`;
            const itemCatalog = itemEditor.catalog || ((itemMap.prefix || '').split('#')[0] || '');
            const itemAllowEmpty = itemEditor.allowEmpty !== false;
            const itemOptions = resolveSymbolOptions(section, key, await getSymbolOptions(itemCatalog), itemEditor);
            if (itemAllowEmpty) {
              const noneOpt = document.createElement('option');
              noneOpt.value = '';
              noneOpt.textContent = '(None)';
              itemSelect.appendChild(noneOpt);
            }
            const itemEntries = getSortedSymbolEntries(itemOptions);
            itemEntries.forEach(({ symbolId, label: optionLabel }) => {
              const opt = document.createElement('option');
              opt.value = symbolId;
              opt.textContent = optionLabel;
              itemSelect.appendChild(opt);
            });
            itemSelect.value = slotState.item ?? '';
            itemSelect.addEventListener('change', async () => {
              await applyNonNumericEdit(section, `${key}.item`, itemSelect.value);
            });
            controlsRow.appendChild(itemSelect);

            const levelMap = slotMap.level || {};
            const levelEditor = { ...levelDefaults, ...slotFieldEditor, ...(levelMap.editor || {}) };
            const levelBounds = resolveNumericBounds(section, `${key}.level`, levelEditor);
            const levelInput = document.createElement('input');
            levelInput.id = `edit-${section}-${key}-level`;
            levelInput.name = `${key}.level`;
            levelInput.type = 'number';
            levelInput.step = '1';
            levelInput.placeholder = 'Level';
            if (levelBounds.min !== null) levelInput.min = String(levelBounds.min);
            if (levelBounds.max !== null) levelInput.max = String(levelBounds.max);
            levelInput.value = normalizeEditorNumericValue(slotState.level, levelEditor);
            levelInput.addEventListener('change', () => {
              handleNumericEdit(section, `${key}.level`, levelInput.value, levelInput, levelEditor);
            });
            controlsRow.appendChild(levelInput);

            wrapper.appendChild(controlsRow);
            editFieldsEl.appendChild(wrapper);
          }

          continue;
        }

        for (const key of sectionMap.keys) {
          const fieldMap = sectionMap[key] || {};
          const sectionFieldEditor = (sectionEditor.fields && sectionEditor.fields[key]) || {};
          const fieldEditor = { ...sectionFieldEditor, ...(fieldMap.editor || {}) };
          if (hiddenKeys.has(key) || fieldEditor.hidden === true) continue;

          const controlType = fieldEditor.type || sectionEditor.type || 'number';
          const bounds = getFieldBounds(section, key);

          const wrapper = document.createElement('div');
          wrapper.className = 'field';

          const label = document.createElement('label');
          label.setAttribute('for', `edit-${section}-${key}`);
          label.textContent = sectionEditor?.labels?.[key] || humanizeKey(key);

          if (controlType !== 'boolean') {
            wrapper.appendChild(label);
          }

          if (controlType === 'number') {
            const numericEditor = { ...sectionEditor, ...fieldEditor };
            const input = document.createElement('input');
            input.id = `edit-${section}-${key}`;
            input.name = key;
            input.type = 'number';
            input.step = '1';
            if (bounds.min !== null) input.min = String(bounds.min);
            if (bounds.max !== null) input.max = String(bounds.max);
            input.value = normalizeEditorNumericValue(state[key], numericEditor);
            input.addEventListener('change', async () => {
              await handleNumericEdit(section, key, input.value, input, numericEditor);
            });
            wrapper.appendChild(input);
          } else if (controlType === 'text') {
            const input = document.createElement('input');
            input.id = `edit-${section}-${key}`;
            input.name = key;
            input.type = 'text';
            input.value = state[key] ?? '';
            if (fieldEditor.maxLength) input.maxLength = Number(fieldEditor.maxLength);
            input.addEventListener('change', async () => {
              const maxLength = fieldEditor.maxLength ? Number(fieldEditor.maxLength) : null;
              const next = maxLength ? input.value.slice(0, maxLength) : input.value;
              input.value = next;
              await applyNonNumericEdit(section, key, next);
            });
            wrapper.appendChild(input);
          } else if (controlType === 'enum') {
            const select = document.createElement('select');
            select.id = `edit-${section}-${key}`;
            select.name = key;
            const options = resolveEnumOptions(section, key, fieldEditor);
            const enumOptions = options.length ? [...options] : [''];
            const currentValue = state[key] ?? '';
            if (!enumOptions.includes(currentValue)) enumOptions.push(currentValue);
            enumOptions.forEach((optValue) => {
              const opt = document.createElement('option');
              opt.value = optValue;
              opt.textContent = optValue === '' ? '(None)' : optValue;
              select.appendChild(opt);
            });
            select.value = state[key] ?? '';
            select.addEventListener('change', async () => {
              await applyNonNumericEdit(section, key, select.value);
            });
            wrapper.appendChild(select);
          } else if (controlType === 'symbol') {
            const select = document.createElement('select');
            select.id = `edit-${section}-${key}`;
            select.name = key;
            const catalog = fieldEditor.catalog || sectionEditor.catalog || ((fieldMap.prefix || sectionMap.prefix || '').split('#')[0] || '');
            const allowEmpty = fieldEditor.allowEmpty !== undefined ? fieldEditor.allowEmpty : (sectionEditor.allowEmpty !== false);
            const options = resolveSymbolOptions(section, key, await getSymbolOptions(catalog), fieldEditor);
            if (allowEmpty) {
              const noneOpt = document.createElement('option');
              noneOpt.value = '';
              noneOpt.textContent = '(None)';
              select.appendChild(noneOpt);
            }
            const symbolEntries = getSortedSymbolEntries(options);
            symbolEntries.forEach(({ symbolId, label: optionLabel }) => {
              const opt = document.createElement('option');
              opt.value = symbolId;
              opt.textContent = optionLabel;
              select.appendChild(opt);
            });
            select.value = state[key] ?? '';
            select.addEventListener('change', async () => {
              await applyNonNumericEdit(section, key, select.value);
            });
            wrapper.appendChild(select);
          } else if (controlType === 'boolean') {
            const checkboxLabel = document.createElement('label');
            checkboxLabel.className = 'field-checkbox';
            checkboxLabel.setAttribute('for', `edit-${section}-${key}`);
            const input = document.createElement('input');
            input.id = `edit-${section}-${key}`;
            input.name = key;
            input.type = 'checkbox';
            input.checked = String(state[key] ?? '0') === '1';
            input.addEventListener('change', async () => {
              await applyNonNumericEdit(section, key, input.checked ? '1' : '0');
            });
            const text = document.createElement('span');
            text.textContent = label.textContent;
            checkboxLabel.appendChild(input);
            checkboxLabel.appendChild(text);
            wrapper.appendChild(checkboxLabel);
          }

          editFieldsEl.appendChild(wrapper);
        }
      }
    };

    const openEditor = async (panelKey) => {
      if (!EDITOR_PANELS[panelKey]) return;
      currentEditSection = panelKey;
      await renderEditorFields(panelKey);
      editPanelEl.hidden = false;
    };

    const closeEditor = () => {
      editPanelEl.hidden = true;
    };

    const setWhatsNewOpen = (nextOpen) => {
      const open = Boolean(nextOpen);
      whatsNewPopoverEl.hidden = !open;
      whatsNewBtnEl.setAttribute('aria-expanded', open ? 'true' : 'false');
    };

    const setEditMode = (next) => {
      isEditMode = Boolean(next);
      editModeBtnEl.textContent = isEditMode ? 'Exit edit mode' : 'Edit mode';
      if (!isEditMode) {
        currentEditSection = null;
        closeEditor();
      }
      const svgEl = document.querySelector('#target svg');
      if (svgEl) decorateInteractivePanels(svgEl);
    };

    const decorateInteractivePanels = (svgEl) => {
      const characterPanel = svgEl.querySelector('#panel-character');
      const equipmentPanel = svgEl.querySelector('#panel-equipment');
      const abilitiesPanel = svgEl.querySelector('#panel-abilities');
      const consumablesPanel = svgEl.querySelector('#panel-consumables');
      const skillsPanel = svgEl.querySelector('#panel-skills');
      const housingPanel = svgEl.querySelector('#panel-housing');
      const cursor = isEditMode ? 'pointer' : '';
      if (characterPanel) characterPanel.style.cursor = cursor;
      if (equipmentPanel) equipmentPanel.style.cursor = cursor;
      if (abilitiesPanel) abilitiesPanel.style.cursor = cursor;
      if (consumablesPanel) consumablesPanel.style.cursor = cursor;
      if (skillsPanel) skillsPanel.style.cursor = cursor;
      if (housingPanel) housingPanel.style.cursor = cursor;
    };

    const renderSheet = async ({ refreshEditor = true } = {}) => {
      if (!currentSvgText || !currentRenderMap || !currentParsed) return;
      const replacements = flatten(currentParsed, currentRenderMap.split, currentRenderMap.joinBy || '-', '');
      const templated = applyReplacements(currentSvgText, replacements);
      targetEl.innerHTML = templated;
      const svgEl = document.querySelector('#target svg');
      if (svgEl) {
        await inlineExternalAssets(svgEl);
        decorateInteractivePanels(svgEl);
      }
      if (refreshEditor && currentEditSection) {
        await renderEditorFields(currentEditSection);
      }
    };

    const onSheetClick = (evt) => {
      if (!isEditMode) return;
      const target = evt.target;
      if (!(target instanceof Element)) return;
      if (target.closest('#panel-character')) {
        openEditor('character');
        return;
      }
      if (target.closest('#panel-equipment')) {
        openEditor('equipment');
        return;
      }
      if (target.closest('#panel-skills')) {
        openEditor('skills');
        return;
      }
      if (target.closest('#panel-abilities')) {
        openEditor('abilities');
        return;
      }
      if (target.closest('#panel-consumables')) {
        openEditor('consumables');
        return;
      }
      if (target.closest('#panel-housing')) {
        openEditor('housing');
      }
    };

    const main = async () => {
      try {
        const urpt = getRawQueryParam('urpt');

        const [svgText, slotRules, itemData, whatsNew] = await Promise.all([fetchSvg(), fetchSlotRules(), fetchItemData(), fetchWhatsNew()]);
        currentSvgText = svgText;
        currentSlotRules = slotRules;
        currentItemData = itemData;
        currentWhatsNew = whatsNew;
        renderWhatsNew(currentWhatsNew);
        itemMetaCache.clear();
        currentRenderMap = readRenderMap(currentSvgText);
        if (!currentRenderMap || !currentRenderMap.split) {
          throw new Error('Missing or invalid render-map');
        }

        currentParsed = parseByMap(urpt, currentRenderMap.split) || {};
        applyEditorDefaults(currentParsed);
        applyComputedCombat(currentParsed);
        await renderSheet();
      } catch (err) {
        targetEl.textContent = 'Render error: ' + err.message;
        console.error(err);
      }
    };

    document.getElementById('copy-img-btn').addEventListener('click', copyImage);
    document.getElementById('copy-lnk-btn').addEventListener('click', copyLink);
    document.getElementById('edit-close-btn').addEventListener('click', closeEditor);
    editModeBtnEl.addEventListener('click', () => setEditMode(!isEditMode));
    whatsNewBtnEl.addEventListener('click', () => setWhatsNewOpen(whatsNewPopoverEl.hidden));
    targetEl.addEventListener('click', onSheetClick);
    document.addEventListener('click', (evt) => {
      if (whatsNewPopoverEl.hidden) return;
      const target = evt.target;
      if (!(target instanceof Element)) return;
      if (!target.closest('#whats-new-anchor')) {
        setWhatsNewOpen(false);
      }
    });
    document.addEventListener('keydown', (evt) => {
      if (evt.key === 'Escape' && !whatsNewPopoverEl.hidden) {
        setWhatsNewOpen(false);
      }
    });
    main();

    async function inlineExternalAssets(svgEl) {
      await Promise.all([
        inlineExternalUses(svgEl),
        inlineExternalImages(svgEl),
      ]);
    }

    async function inlineExternalUses(svgEl) {
      const uses = Array.from(svgEl.querySelectorAll('use'));
      if (!uses.length) return;

      const refs = [];
      uses.forEach((el) => {
        const href = el.getAttribute('href') || el.getAttribute('xlink:href');
        if (!href || href.startsWith('#')) return;
        const [file, symbolId] = href.split('#');
        if (!file || !symbolId) return;
        refs.push({ file, symbolId, el });
      });
      if (!refs.length) return;

      const defs = svgEl.querySelector('defs') || svgEl.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svgEl.firstChild);
      const files = [...new Set(refs.map((r) => r.file))];

      await Promise.all(files.map(async (file) => {
        if (symbolFileCache.has(file)) return;
        const res = await fetch(file);
        if (!res.ok) return;
        symbolFileCache.set(file, await res.text());
      }));

      const parsedByFile = new Map();
      files.forEach((file) => {
        const text = symbolFileCache.get(file);
        if (text) parsedByFile.set(file, new DOMParser().parseFromString(text, 'image/svg+xml'));
      });

      const idMap = new Map();
      refs.forEach(({ file, symbolId, el }) => {
        const doc = parsedByFile.get(file);
        if (!doc) return;
        const key = `${file}#${symbolId}`;
        let newId = idMap.get(key);
        if (!newId) {
          const symbol = doc.getElementById(symbolId);
          if (!symbol) return;
          const safeFile = file.replace(/[^\w-]/g, '_');
          newId = `${safeFile}__${symbolId}`;
          idMap.set(key, newId);
          if (!defs.querySelector(`[id="${newId}"]`)) {
            const cloned = symbol.cloneNode(true);
            cloned.setAttribute('id', newId);
            defs.appendChild(cloned);
          }
        }
        const href = el.getAttribute('href') || el.getAttribute('xlink:href');
        if (href && href.startsWith(`${file}#${symbolId}`)) {
          el.setAttribute('href', `#${newId}`);
          el.removeAttribute('xlink:href');
        }
      });
    }

    async function inlineExternalImages(svgEl) {
      const images = Array.from(svgEl.querySelectorAll('image'));
      if (!images.length) return;

      const toDataUrl = (blob) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      const hrefs = [...new Set(images
        .map((img) => img.getAttribute('href') || img.getAttribute('xlink:href'))
        .filter((h) => h && !h.startsWith('#') && !h.startsWith('data:')))];

      await Promise.all(hrefs.map(async (href) => {
        if (imageDataCache.has(href)) return;
        const res = await fetch(href);
        if (!res.ok) return;
        const blob = await res.blob();
        imageDataCache.set(href, await toDataUrl(blob));
      }));

      images.forEach((img) => {
        const href = img.getAttribute('href') || img.getAttribute('xlink:href');
        if (!href || href.startsWith('#') || href.startsWith('data:')) return;
        const dataUrl = imageDataCache.get(href);
        if (dataUrl) {
          img.setAttribute('href', dataUrl);
          img.removeAttribute('xlink:href');
        }
      });
    }

    function applyComputedCombat(parsed) {
      if (!parsed || !parsed.skills) return;
      const s = parsed.skills;

      const fields = ['stamina', 'intelligence', 'attack', 'defense', 'melee', 'ranged', 'magic'];
      const hasOthers = fields.some((k) => (s[k] ?? '').toString().trim() !== '');
      if (!hasOthers) {
        s.combat = '';
        return;
      }

      const num = (val) => {
        const n = parseFloat(val);
        return Number.isFinite(n) ? n : 0;
      };

      const stamina = num(s.stamina);
      const intelligence = num(s.intelligence);
      const attack = num(s.attack);
      const defense = num(s.defense);
      const melee = num(s.melee);
      const ranged = num(s.ranged);
      const magic = num(s.magic);
      const maxOffense = Math.max(melee, ranged, magic);
      const base = 0.1 * (stamina + intelligence + attack + defense + maxOffense);
      const boost = 0.5 * Math.max(attack, defense, melee, ranged, magic);
      const combatLevel = Math.round(base + boost);
      s.combat = combatLevel.toString();
    }

    function applyEditorDefaults(parsed) {
      if (!parsed || typeof parsed !== 'object') return;

      const housingMap = currentRenderMap?.split?.housing;
      const housingState = parsed.housing;
      const housingEditor = housingMap?.editor || {};
      if (housingMap && housingState && typeof housingState === 'object' && housingEditor.emptyWhenZero === true) {
        housingMap.keys.forEach((key) => {
          housingState[key] = normalizeEditorNumericValue(housingState[key], housingEditor);
        });
      }

      const equipmentMap = currentRenderMap?.split?.equipment;
      const equipmentState = parsed.equipment;
      if (!equipmentMap || !equipmentState || typeof equipmentState !== 'object') return;
      const equipmentLevelEditor = equipmentMap?.editor?.level || {};
      if (equipmentLevelEditor.emptyWhenZero !== true) return;

      equipmentMap.keys.forEach((key) => {
        const slotState = equipmentState[key];
        if (!slotState || typeof slotState !== 'object') return;
        slotState.level = normalizeEditorNumericValue(slotState.level, equipmentLevelEditor);
      });
    }
  </script>
</body>
</html>
