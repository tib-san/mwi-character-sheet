<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MWI Character Sheet Render</title>
  <style>
    body { margin: 0; background: #0b1020; color: #e7e7e7; font-family: system-ui, sans-serif; }
    #target { width: 870px; height: 610px; display: block; margin: 20px auto; }
    .copy-btn {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      padding: 10px 16px;
      background: #24304f;
      color: #e7e7e7;
      border: 1px solid #3a4a70;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #button-row{ display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 20px; margin: 20px auto 0; }
    #copy-img-btn:disabled { opacity: 0.6; cursor: progress; }
  </style>
</head>
<body>
  <div id="target">Loading…</div>
  <div id="button-row">
    <button id="copy-img-btn" class="copy-btn" type="button">Copy image</button>
    <button id="copy-lnk-btn" class="copy-btn" type="button">Copy link</button>
  </div>
  <script type="module">
    const svgUrl = './loadout_combat.svg';
    const symbolFileCache = new Map();
    const imageDataCache = new Map();
    let currentParsed = null;

    const fetchSvg = async () => {
      const res = await fetch(svgUrl);
      if (!res.ok) throw new Error('Failed to fetch SVG');
      return res.text();
    };

    const readRenderMap = (svgText) => {
      const match = svgText.match(/render-map:\s*([\s\S]*?)-->/);
      if (!match) return null;
      try { return JSON.parse(match[1]); } catch (e) { return null; }
    };

    const splitWithKeys = (str, delimiter, keys) => {
      if (!keys || !Array.isArray(keys)) return {};
      const parts = delimiter !== null && delimiter !== undefined ? (str ? str.split(delimiter) : []) : [str];
      const out = {};
      keys.forEach((k, idx) => { out[k] = parts[idx] !== undefined ? parts[idx] : ''; });
      return out;
    };

    const parseByMap = (str, mapNode) => {
      if (!mapNode || !mapNode.keys) return str;
      const base = splitWithKeys(str, mapNode.delimiter, mapNode.keys);
      const result = {};
      mapNode.keys.forEach((k) => {
        const childMap = mapNode[k];
        const val = base[k] === undefined ? '' : base[k];
        result[k] = childMap ? parseByMap(val, childMap) : val;
      });
      return result;
    };

    const flatten = (obj, mapNode, joinBy, prefixKey = '', inherited = {}, out = {}) => {
      if (obj === null || obj === undefined) return out;
      if (!mapNode) return out;
      const currentPrefix = mapNode.prefix !== undefined ? mapNode.prefix : inherited.prefix;
      const currentDefault = mapNode.default !== undefined ? mapNode.default : inherited.default;

      if (!mapNode.keys || typeof obj !== 'object') {
        const val = (obj === '' || obj === undefined || obj === null) ? (currentDefault !== undefined ? currentDefault : '') : obj;
        const finalVal = currentPrefix && val ? `${currentPrefix}${val}` : val;
        if (prefixKey) out[prefixKey] = finalVal;
        return out;
      }

      mapNode.keys.forEach((k) => {
        const nextKey = prefixKey ? `${prefixKey}${joinBy}${k}` : k;
        const childMap = mapNode[k] || {};
        const childVal = obj[k] !== undefined ? obj[k] : '';
        if (typeof childVal === 'object' && childVal !== null && childMap.keys) {
          flatten(childVal, childMap, joinBy, nextKey, { prefix: childMap.prefix ?? currentPrefix, default: childMap.default ?? currentDefault }, out);
        } else {
          const val = (childVal === '' || childVal === undefined || childVal === null) ? (childMap.default !== undefined ? childMap.default : currentDefault !== undefined ? currentDefault : '') : childVal;
          const finalVal = (childMap.prefix !== undefined ? childMap.prefix : currentPrefix) && val ? `${childMap.prefix !== undefined ? childMap.prefix : currentPrefix}${val}` : val;
          out[nextKey] = finalVal;
        }
      });
      return out;
    };

    const applyReplacements = (svgText, replacements) => {
      let out = svgText;
      Object.entries(replacements).forEach(([key, val]) => {
        const re = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        out = out.replace(re, val === undefined || val === null ? '' : String(val));
      });
      return out;
    };

    const getSvgDimensions = (svgEl) => {
      const viewBox = svgEl.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.split(/[\s,]+/).map((p) => parseFloat(p));
        if (parts.length === 4 && !parts.some(Number.isNaN)) return { width: parts[2], height: parts[3] };
      }

      const widthAttr = parseFloat(svgEl.getAttribute('width'));
      const heightAttr = parseFloat(svgEl.getAttribute('height'));
      if (!Number.isNaN(widthAttr) && !Number.isNaN(heightAttr) && widthAttr && heightAttr) {
        return { width: widthAttr, height: heightAttr };
      }

      const rect = svgEl.getBoundingClientRect();
      if (rect.width && rect.height) return { width: rect.width, height: rect.height };

      return { width: 870, height: 610 }; // sensible fallback matching layout
    };

    const svgToPngBlob = async (svgEl) => new Promise((resolve, reject) => {
      const clone = svgEl.cloneNode(true);
      if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      inlineExternalAssets(clone).then(() => {
        const serialized = new XMLSerializer().serializeToString(clone);
        const svgBlob = new Blob([serialized], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        const { width, height } = getSvgDimensions(svgEl);

        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d', { willReadFrequently: false });
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          canvas.toBlob((blob) => {
            URL.revokeObjectURL(url);
            if (blob) resolve(blob);
            else reject(new Error('Canvas export failed'));
          }, 'image/png');
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('SVG could not be loaded for export'));
        };

        img.src = url;
      }).catch(reject);
    });

    const copyImage = async () => {
      const btn = document.getElementById('copy-img-btn');
      const svgEl = document.querySelector('#target svg');
      if (!navigator.clipboard || !window.ClipboardItem) {
        btn.textContent = 'Clipboard not supported';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 2000);
        return;
      }
      if (!svgEl) {
        btn.textContent = 'SVG not ready';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 1500);
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Copying…';
      try {
        const blobPromise = svgToPngBlob(svgEl); // start immediately to retain activation
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blobPromise })]);
        await blobPromise; // ensure completion before success message
        btn.textContent = 'Copied!';
      } catch (err) {
        console.error(err);
        btn.textContent = 'Copy failed';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = 'Copy image';
        }, 1200);
      }
    };

    const copyLink = async () => {
      const btn = document.getElementById('copy-lnk-btn');
      if (!navigator.clipboard || !window.ClipboardItem) {
        btn.textContent = 'Clipboard not supported';
        setTimeout(() => { btn.textContent = 'Copy link'; }, 2000);
        return;
      }

      const name = currentParsed?.general?.name || 'Player';
      const combat = currentParsed?.skills?.combat || '';
      const label = `Combat Sheet for ${name}` + ( combat ? ` (CL ${combat})` : "" );
      const url = location.href;

      const html = `<a href="${url}">${label}</a>`;
      const plain = `[${label}](${url})`;

      const item = new ClipboardItem({
        'text/html': new Blob([html], { type: 'text/html' }),
        'text/plain': new Blob([plain], { type: 'text/plain' }),
      });

      btn.disabled = true;
      btn.textContent = 'Copying…';
      try {
        await navigator.clipboard.write([item]);
        btn.textContent = 'Copied!';
      } catch (err) {
        console.error(err);
        btn.textContent = 'Copy failed';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = 'Copy link';
        }, 1200);
      }
    };

    const main = async () => {
      try {
        const urlParams = new URLSearchParams(location.search);
        const urpt = urlParams.get('urpt') || '';
        const svgText = await fetchSvg();
        const renderMap = readRenderMap(svgText);
        const parsed = (urpt && renderMap && renderMap.split) ? (parseByMap(urpt, renderMap.split) || {}) : {};
        applyComputedCombat(parsed);
        currentParsed = parsed;
        const replacements = flatten(parsed, renderMap ? renderMap.split : null, renderMap ? renderMap.joinBy || '-' : '-', '');
        const templated = applyReplacements(svgText, replacements);
        document.getElementById('target').innerHTML = templated;
        const svgEl = document.querySelector('#target svg');
        if (svgEl) await inlineExternalAssets(svgEl); // prime caches so copying is instant
      } catch (err) {
        document.getElementById('target').textContent = 'Render error: ' + err.message;
        console.error(err);
      }
    };

    document.getElementById('copy-img-btn').addEventListener('click', copyImage);
    document.getElementById('copy-lnk-btn').addEventListener('click', copyLink);
    main();

    async function inlineExternalAssets(svgEl) {
      await Promise.all([
        inlineExternalUses(svgEl),
        inlineExternalImages(svgEl),
      ]);
    }

    async function inlineExternalUses(svgEl) {
      const uses = Array.from(svgEl.querySelectorAll('use'));
      if (!uses.length) return;

      const refs = [];
      uses.forEach((el) => {
        const href = el.getAttribute('href') || el.getAttribute('xlink:href');
        if (!href || href.startsWith('#')) return;
        const [file, symbolId] = href.split('#');
        if (!file || !symbolId) return;
        refs.push({ file, symbolId, el });
      });
      if (!refs.length) return;

      const defs = svgEl.querySelector('defs') || svgEl.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svgEl.firstChild);
      const files = [...new Set(refs.map((r) => r.file))];

      // Fetch symbol files in parallel with caching
      await Promise.all(files.map(async (file) => {
        if (symbolFileCache.has(file)) return;
        const res = await fetch(file);
        if (!res.ok) return;
        symbolFileCache.set(file, await res.text());
      }));

      const parsedByFile = new Map();
      files.forEach((file) => {
        const text = symbolFileCache.get(file);
        if (text) parsedByFile.set(file, new DOMParser().parseFromString(text, 'image/svg+xml'));
      });

      const idMap = new Map(); // key: file#symbolId -> newId
      refs.forEach(({ file, symbolId, el }) => {
        const doc = parsedByFile.get(file);
        if (!doc) return;
        const key = `${file}#${symbolId}`;
        let newId = idMap.get(key);
        if (!newId) {
          const symbol = doc.getElementById(symbolId);
          if (!symbol) return;
          const safeFile = file.replace(/[^\w-]/g, '_');
          newId = `${safeFile}__${symbolId}`;
          idMap.set(key, newId);
          if (!defs.querySelector(`[id="${newId}"]`)) {
            const cloned = symbol.cloneNode(true);
            cloned.setAttribute('id', newId);
            defs.appendChild(cloned);
          }
        }
        const href = el.getAttribute('href') || el.getAttribute('xlink:href');
        if (href && href.startsWith(`${file}#${symbolId}`)) {
          el.setAttribute('href', `#${newId}`);
          el.removeAttribute('xlink:href');
        }
      });
    }

    async function inlineExternalImages(svgEl) {
      const images = Array.from(svgEl.querySelectorAll('image'));
      if (!images.length) return;

      const toDataUrl = (blob) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      const hrefs = [...new Set(images.map((img) => img.getAttribute('href') || img.getAttribute('xlink:href')).filter((h) => h && !h.startsWith('#') && !h.startsWith('data:')))];

      await Promise.all(hrefs.map(async (href) => {
        if (imageDataCache.has(href)) return;
        const res = await fetch(href);
        if (!res.ok) return;
        const blob = await res.blob();
        imageDataCache.set(href, await toDataUrl(blob));
      }));

      images.forEach((img) => {
        const href = img.getAttribute('href') || img.getAttribute('xlink:href');
        if (!href || href.startsWith('#') || href.startsWith('data:')) return;
        const dataUrl = imageDataCache.get(href);
        if (dataUrl) {
          img.setAttribute('href', dataUrl);
          img.removeAttribute('xlink:href');
        }
      });
    }

    function applyComputedCombat(parsed) {
      if (!parsed || !parsed.skills) return;
      const s = parsed.skills;
      if (s.combat && String(s.combat).trim() !== '') return;

      const fields = ['stamina', 'intelligence', 'attack', 'defense', 'melee', 'ranged', 'magic'];
      const hasOthers = fields.some((k) => (s[k] ?? '').toString().trim() !== '');
      if (!hasOthers) return;

      const num = (val) => {
        const n = parseFloat(val);
        return Number.isFinite(n) ? n : 0;
      };

      const stamina = num(s.stamina);
      const intelligence = num(s.intelligence);
      const attack = num(s.attack);
      const defense = num(s.defense);
      const melee = num(s.melee);
      const ranged = num(s.ranged);
      const magic = num(s.magic);
      const maxOffense = Math.max(melee, ranged, magic);
      const base = 0.1 * (stamina + intelligence + attack + defense + maxOffense);
      const boost = 0.5 * Math.max(attack, defense, melee, ranged, magic);
      const combatLevel = Math.round(base + boost);
      s.combat = combatLevel.toString();
    }
  </script>
</body>
</html>
