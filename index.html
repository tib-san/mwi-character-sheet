<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MWI Character Sheet Render</title>
  <style>
    body { margin: 0; background: #0b1020; color: #e7e7e7; font-family: system-ui, sans-serif; }
    #target { width: 870px; height: 610px; display: block; margin: 20px auto; }
    #copy-btn {
      display: block;
      margin: 20px auto 0;
      padding: 10px 16px;
      background: #24304f;
      color: #e7e7e7;
      border: 1px solid #3a4a70;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #copy-btn:disabled { opacity: 0.6; cursor: progress; }
  </style>
</head>
<body>
  <button id="copy-btn" type="button">Copy image</button>
  <div id="target">Loading…</div>
  <script type="module">
    const svgUrl = './loadout_combat.svg';

    const fetchSvg = async () => {
      const res = await fetch(svgUrl);
      if (!res.ok) throw new Error('Failed to fetch SVG');
      return res.text();
    };

    const readRenderMap = (svgText) => {
      const match = svgText.match(/render-map:\s*([\s\S]*?)-->/);
      if (!match) return null;
      try { return JSON.parse(match[1]); } catch (e) { return null; }
    };

    const splitWithKeys = (str, delimiter, keys) => {
      if (!keys || !Array.isArray(keys)) return {};
      const parts = delimiter !== null && delimiter !== undefined ? (str ? str.split(delimiter) : []) : [str];
      const out = {};
      keys.forEach((k, idx) => { out[k] = parts[idx] !== undefined ? parts[idx] : ''; });
      return out;
    };

    const parseByMap = (str, mapNode) => {
      if (!mapNode || !mapNode.keys) return str;
      const base = splitWithKeys(str, mapNode.delimiter, mapNode.keys);
      const result = {};
      mapNode.keys.forEach((k) => {
        const childMap = mapNode[k];
        const val = base[k] === undefined ? '' : base[k];
        result[k] = childMap ? parseByMap(val, childMap) : val;
      });
      return result;
    };

    const flatten = (obj, mapNode, joinBy, prefixKey = '', inherited = {}, out = {}) => {
      if (obj === null || obj === undefined) return out;
      if (!mapNode) return out;
      const currentPrefix = mapNode.prefix !== undefined ? mapNode.prefix : inherited.prefix;
      const currentDefault = mapNode.default !== undefined ? mapNode.default : inherited.default;

      if (!mapNode.keys || typeof obj !== 'object') {
        const val = (obj === '' || obj === undefined || obj === null) ? (currentDefault !== undefined ? currentDefault : '') : obj;
        const finalVal = currentPrefix && val ? `${currentPrefix}${val}` : val;
        if (prefixKey) out[prefixKey] = finalVal;
        return out;
      }

      mapNode.keys.forEach((k) => {
        const nextKey = prefixKey ? `${prefixKey}${joinBy}${k}` : k;
        const childMap = mapNode[k] || {};
        const childVal = obj[k] !== undefined ? obj[k] : '';
        if (typeof childVal === 'object' && childVal !== null && childMap.keys) {
          flatten(childVal, childMap, joinBy, nextKey, { prefix: childMap.prefix ?? currentPrefix, default: childMap.default ?? currentDefault }, out);
        } else {
          const val = (childVal === '' || childVal === undefined || childVal === null) ? (childMap.default !== undefined ? childMap.default : currentDefault !== undefined ? currentDefault : '') : childVal;
          const finalVal = (childMap.prefix !== undefined ? childMap.prefix : currentPrefix) && val ? `${childMap.prefix !== undefined ? childMap.prefix : currentPrefix}${val}` : val;
          out[nextKey] = finalVal;
        }
      });
      return out;
    };

    const applyReplacements = (svgText, replacements) => {
      let out = svgText;
      Object.entries(replacements).forEach(([key, val]) => {
        const re = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        out = out.replace(re, val === undefined || val === null ? '' : String(val));
      });
      return out;
    };

    const getSvgDimensions = (svgEl) => {
      const viewBox = svgEl.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.split(/[\s,]+/).map((p) => parseFloat(p));
        if (parts.length === 4 && !parts.some(Number.isNaN)) return { width: parts[2], height: parts[3] };
      }

      const widthAttr = parseFloat(svgEl.getAttribute('width'));
      const heightAttr = parseFloat(svgEl.getAttribute('height'));
      if (!Number.isNaN(widthAttr) && !Number.isNaN(heightAttr) && widthAttr && heightAttr) {
        return { width: widthAttr, height: heightAttr };
      }

      const rect = svgEl.getBoundingClientRect();
      if (rect.width && rect.height) return { width: rect.width, height: rect.height };

      return { width: 870, height: 610 }; // sensible fallback matching layout
    };

    const svgToPngBlob = async (svgEl) => new Promise((resolve, reject) => {
      const clone = svgEl.cloneNode(true);
      if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      const serialized = new XMLSerializer().serializeToString(clone);
      const svgBlob = new Blob([serialized], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(svgBlob);
      const img = new Image();
      const { width, height } = getSvgDimensions(svgEl);

      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d', { willReadFrequently: false });
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob((blob) => {
          URL.revokeObjectURL(url);
          if (blob) resolve(blob);
          else reject(new Error('Canvas export failed'));
        }, 'image/png');
      };

      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('SVG could not be loaded for export'));
      };

      img.src = url;
    });

    const copyImage = async () => {
      const btn = document.getElementById('copy-btn');
      const svgEl = document.querySelector('#target svg');
      if (!navigator.clipboard || !window.ClipboardItem) {
        btn.textContent = 'Clipboard not supported';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 2000);
        return;
      }
      if (!svgEl) {
        btn.textContent = 'SVG not ready';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 1500);
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Copying…';
      try {
        const blob = await svgToPngBlob(svgEl);
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        btn.textContent = 'Copied!';
      } catch (err) {
        console.error(err);
        btn.textContent = 'Copy failed';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = 'Copy image';
        }, 1200);
      }
    };

    const main = async () => {
      try {
        const urlParams = new URLSearchParams(location.search);
        const urpt = urlParams.get('urpt') || '';
        const svgText = await fetchSvg();
        const renderMap = readRenderMap(svgText);
        const parsed = (urpt && renderMap && renderMap.split) ? (parseByMap(urpt, renderMap.split) || {}) : {};
        const replacements = flatten(parsed, renderMap ? renderMap.split : null, renderMap ? renderMap.joinBy || '-' : '-', '');
        const templated = applyReplacements(svgText, replacements);
        document.getElementById('target').innerHTML = templated;
      } catch (err) {
        document.getElementById('target').textContent = 'Render error: ' + err.message;
        console.error(err);
      }
    };

    document.getElementById('copy-btn').addEventListener('click', copyImage);
    main();
  </script>
</body>
</html>
