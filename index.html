<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MWI Character Sheet Render</title>
  <style>
    body { margin: 0; background: #0b1020; color: #e7e7e7; font-family: system-ui, sans-serif; }
    #target { width: 870px; height: 610px; display: block; margin: 20px auto; }
    #copy-btn {
      display: block;
      margin: 20px auto 0;
      padding: 10px 16px;
      background: #24304f;
      color: #e7e7e7;
      border: 1px solid #3a4a70;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #copy-btn:disabled { opacity: 0.6; cursor: progress; }
  </style>
</head>
<body>
  <button id="copy-btn" type="button">Copy image</button>
  <div id="target">Loading…</div>
  <script type="module">
    const svgUrl = './loadout_combat.svg';

    const fetchSvg = async () => {
      const res = await fetch(svgUrl);
      if (!res.ok) throw new Error('Failed to fetch SVG');
      return res.text();
    };

    const readRenderMap = (svgText) => {
      const match = svgText.match(/render-map:\s*([\s\S]*?)-->/);
      if (!match) return null;
      try { return JSON.parse(match[1]); } catch (e) { return null; }
    };

    const splitWithKeys = (str, delimiter, keys) => {
      if (!keys || !Array.isArray(keys)) return {};
      const parts = delimiter !== null && delimiter !== undefined ? (str ? str.split(delimiter) : []) : [str];
      const out = {};
      keys.forEach((k, idx) => { out[k] = parts[idx] !== undefined ? parts[idx] : ''; });
      return out;
    };

    const parseByMap = (str, mapNode) => {
      if (!mapNode || !mapNode.keys) return str;
      const base = splitWithKeys(str, mapNode.delimiter, mapNode.keys);
      const result = {};
      mapNode.keys.forEach((k) => {
        const childMap = mapNode[k];
        const val = base[k] === undefined ? '' : base[k];
        result[k] = childMap ? parseByMap(val, childMap) : val;
      });
      return result;
    };

    const flatten = (obj, mapNode, joinBy, prefixKey = '', inherited = {}, out = {}) => {
      if (obj === null || obj === undefined) return out;
      if (!mapNode) return out;
      const currentPrefix = mapNode.prefix !== undefined ? mapNode.prefix : inherited.prefix;
      const currentDefault = mapNode.default !== undefined ? mapNode.default : inherited.default;

      if (!mapNode.keys || typeof obj !== 'object') {
        const val = (obj === '' || obj === undefined || obj === null) ? (currentDefault !== undefined ? currentDefault : '') : obj;
        const finalVal = currentPrefix && val ? `${currentPrefix}${val}` : val;
        if (prefixKey) out[prefixKey] = finalVal;
        return out;
      }

      mapNode.keys.forEach((k) => {
        const nextKey = prefixKey ? `${prefixKey}${joinBy}${k}` : k;
        const childMap = mapNode[k] || {};
        const childVal = obj[k] !== undefined ? obj[k] : '';
        if (typeof childVal === 'object' && childVal !== null && childMap.keys) {
          flatten(childVal, childMap, joinBy, nextKey, { prefix: childMap.prefix ?? currentPrefix, default: childMap.default ?? currentDefault }, out);
        } else {
          const val = (childVal === '' || childVal === undefined || childVal === null) ? (childMap.default !== undefined ? childMap.default : currentDefault !== undefined ? currentDefault : '') : childVal;
          const finalVal = (childMap.prefix !== undefined ? childMap.prefix : currentPrefix) && val ? `${childMap.prefix !== undefined ? childMap.prefix : currentPrefix}${val}` : val;
          out[nextKey] = finalVal;
        }
      });
      return out;
    };

    const applyReplacements = (svgText, replacements) => {
      let out = svgText;
      Object.entries(replacements).forEach(([key, val]) => {
        const re = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        out = out.replace(re, val === undefined || val === null ? '' : String(val));
      });
      return out;
    };

    const getSvgDimensions = (svgEl) => {
      const viewBox = svgEl.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.split(/[\s,]+/).map((p) => parseFloat(p));
        if (parts.length === 4 && !parts.some(Number.isNaN)) return { width: parts[2], height: parts[3] };
      }

      const widthAttr = parseFloat(svgEl.getAttribute('width'));
      const heightAttr = parseFloat(svgEl.getAttribute('height'));
      if (!Number.isNaN(widthAttr) && !Number.isNaN(heightAttr) && widthAttr && heightAttr) {
        return { width: widthAttr, height: heightAttr };
      }

      const rect = svgEl.getBoundingClientRect();
      if (rect.width && rect.height) return { width: rect.width, height: rect.height };

      return { width: 870, height: 610 }; // sensible fallback matching layout
    };

    const svgToPngBlob = async (svgEl) => new Promise((resolve, reject) => {
      const clone = svgEl.cloneNode(true);
      if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      inlineExternalAssets(clone).then(() => {
        const serialized = new XMLSerializer().serializeToString(clone);
        const svgBlob = new Blob([serialized], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        const { width, height } = getSvgDimensions(svgEl);

        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d', { willReadFrequently: false });
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          canvas.toBlob((blob) => {
            URL.revokeObjectURL(url);
            if (blob) resolve(blob);
            else reject(new Error('Canvas export failed'));
          }, 'image/png');
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('SVG could not be loaded for export'));
        };

        img.src = url;
      }).catch(reject);
    });

    const copyImage = async () => {
      const btn = document.getElementById('copy-btn');
      const svgEl = document.querySelector('#target svg');
      if (!navigator.clipboard || !window.ClipboardItem) {
        btn.textContent = 'Clipboard not supported';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 2000);
        return;
      }
      if (!svgEl) {
        btn.textContent = 'SVG not ready';
        setTimeout(() => { btn.textContent = 'Copy image'; }, 1500);
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Copying…';
      try {
        const blobPromise = svgToPngBlob(svgEl); // start immediately to retain activation
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blobPromise })]);
        await blobPromise; // ensure completion before success message
        btn.textContent = 'Copied!';
      } catch (err) {
        console.error(err);
        btn.textContent = 'Copy failed';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = 'Copy image';
        }, 1200);
      }
    };

    const main = async () => {
      try {
        const urlParams = new URLSearchParams(location.search);
        const urpt = urlParams.get('urpt') || '';
        const svgText = await fetchSvg();
        const renderMap = readRenderMap(svgText);
        const parsed = (urpt && renderMap && renderMap.split) ? (parseByMap(urpt, renderMap.split) || {}) : {};
        const replacements = flatten(parsed, renderMap ? renderMap.split : null, renderMap ? renderMap.joinBy || '-' : '-', '');
        const templated = applyReplacements(svgText, replacements);
        document.getElementById('target').innerHTML = templated;
      } catch (err) {
        document.getElementById('target').textContent = 'Render error: ' + err.message;
        console.error(err);
      }
    };

    document.getElementById('copy-btn').addEventListener('click', copyImage);
    main();

    async function inlineExternalAssets(svgEl) {
      await Promise.all([
        inlineExternalUses(svgEl),
        inlineExternalImages(svgEl),
      ]);
    }

    async function inlineExternalUses(svgEl) {
      const uses = Array.from(svgEl.querySelectorAll('use'));
      if (!uses.length) return;

      const refs = [];
      uses.forEach((el) => {
        const href = el.getAttribute('href') || el.getAttribute('xlink:href');
        if (!href || href.startsWith('#')) return;
        const [file, symbolId] = href.split('#');
        if (!file || !symbolId) return;
        refs.push({ file, symbolId });
      });
      if (!refs.length) return;

      const defs = svgEl.querySelector('defs') || svgEl.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svgEl.firstChild);
      const fileCache = new Map();

      for (const { file, symbolId } of refs) {
        if (!fileCache.has(file)) {
          const res = await fetch(file);
          if (!res.ok) continue;
          const text = await res.text();
          fileCache.set(file, text);
        }
        const svgText = fileCache.get(file);
        const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
        const symbol = doc.getElementById(symbolId);
        if (symbol && !defs.querySelector(`[id="${symbolId}"]`)) {
          defs.appendChild(symbol.cloneNode(true));
        }
        uses.forEach((el) => {
          const href = el.getAttribute('href') || el.getAttribute('xlink:href');
          if (href && href.startsWith(`${file}#${symbolId}`)) {
            el.setAttribute('href', `#${symbolId}`);
            el.removeAttribute('xlink:href');
          }
        });
      }
    }

    async function inlineExternalImages(svgEl) {
      const images = Array.from(svgEl.querySelectorAll('image'));
      if (!images.length) return;
      const cache = new Map();

      const toDataUrl = (blob) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      for (const img of images) {
        const href = img.getAttribute('href') || img.getAttribute('xlink:href');
        if (!href || href.startsWith('#') || href.startsWith('data:')) continue;
        if (!cache.has(href)) {
          const res = await fetch(href);
          if (!res.ok) continue;
          const blob = await res.blob();
          cache.set(href, await toDataUrl(blob));
        }
        img.setAttribute('href', cache.get(href));
        img.removeAttribute('xlink:href');
      }
    }
  </script>
</body>
</html>
